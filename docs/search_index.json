[["index.html", "Intro to SQL for Querying Databases Overview", " Intro to SQL for Querying Databases Nicholas Alonzo Michele Tobias 2022-04-05 Overview Structured Query Language (SQL) is a programming language for interacting with relational databases. This workshop covers basic SQL commands to view, filter, aggregate, and combine tables in a database. SQL is supported by many different database systems. The examples in this workshop use a SQLite database, but most of the commands are applicable to other database systems as well. The workshop also covers how to use SQLiteStudio, an integrated development environment for SQL code. We’ll focus on querying data to get to know a database and answer questions, and joining data from separate tables. Learning Objectives After this workshop learners should be able to: Describe the advantages and disadvantages of using SQL for data problems. Use SQL queries to view, filter, aggregate, and combine data. Combine SQL keywords to develop sophisticated queries. Use SQL queries to solve problems with and answer questions about data. Identify additional resources for learning more about SQL (such as how to use SQL with the R programming language). Prerequisites No prior programming experience is necessary. Before the workshop, learners should: Install SQLiteStudio and verify that it runs. See the install guide for details. Download the file 2022-04-04_intro-sql.zip from this link. Unzip the file and keep track of where it’s saved on your computer. It contains a data set and a script that will be used during the workshop: lcdb.db intro_to_sql_spring22.sql "],["concepts.html", "1 Concepts 1.1 What is a Relational Database? 1.2 What is SQL? 1.3 What is a Relational Database Management System? 1.4 Advantages &amp; Disadvantages of SQL", " 1 Concepts 1.1 What is a Relational Database? A relational database is a collection of tables (organized in rows and columns of data) that are related to each other in some way. If you’ve worked in Microsoft Excel this would be the equivalent to sheets of data. Or, if you have experience with R or Python programming languages, this would be the equivalent to data frames. We’ll go more in-depth on the relational part when we cover the workshop dataset! 1.2 What is SQL? SQL stands for structured query language. SQL is a programming language that allows you to answer questions about the data in a database using a standard set of commands. You can pronounce SQL as “ess cue ell” or “sequel”. 1.2.1 What kinds of questions can SQL answer? If you already work with data, you probably think about answering specific questions such as: How many of X or Y are there? What are the unique values of X? Which of X, Y, and Z that occurred in a given time period? You can use SQL to answer these kinds of questions. 1.2.2 The Basics of Writing SQL Code Today we’ll learn about all the following common SQL commands and how they’re used together to view, filter, aggregate, and join data. SELECT [DISTINCT] ... FROM ... [WHERE ...] [ [INNER | LEFT] JOIN ...] [GROUP BY ... [HAVING ...]] [ORDER BY ...] [LIMIT ...]; NOTE: Commands in brackets “[ ]” are optional Write commands in the order of the blueprint End queries with a semicolon “;” 1.3 What is a Relational Database Management System? A relational database management system (RDBMS) is a software system that manages the users of and tables within a database. There are many different systems available. For instance, you may have heard of MySQL, Postgres, and Microsoft SQL Server. For this workshop, we’ll use SQLite, which is likely the simplest and most widely-used RDBMS. It runs on Windows, MacOS X, and Linux with no setup necessary! Every RDBMS has its own implementation or “dialect” of SQL. In other words, the set of SQL commands supported differs from one RDBMS to another, and sometimes queries have to be written differently. Details about the supported commands for a given RDBMS can be found in that system’s documentation. The commands covered in this workshop are supported by almost all popular systems. 1.4 Advantages &amp; Disadvantages of SQL SQL queries are declarative: you describe the data that you want. Then it’s up to SQL to determine the most efficient way to get that data. This approach to programming has several advantages: You can work with very large data sets. Databases are typically stored on your computer’s hard disk, and only the results from queries need to fit in memory (and there are ways to work around even this limitation). Queries are relatively fast compared to other data programming tools (such as R or Python). This is because the database system is free to choose the most efficient way to run the query. Queries are reproducible. You can save, edit, and run queries at a later date. SQL is less expressive and flexible than other data programming tools, so there are not too many different commands to remember. SQL also has a few disadvantages: SQL is less expressive and flexible than other data programming tools. For instance, you can’t use SQL to make a plot. Each RDBMS has its own dialect of SQL, so each time you work with a new database, you must familiarize yourself with which commands are supported. Setting up most database systems (other than SQLite) is a relatively complicated process. "],["the-library-checkouts-database.html", "2 The Library Checkouts Database 2.1 Entity Relationship Diagrams 2.2 Data Definitions 2.3 SQLiteStudio", " 2 The Library Checkouts Database We’ll be working with the Library Checkouts Database, a fictitious SQLite database about how and what a library keeps track of when lending books. This includes information like: Books and their details: title, author, genres, etc… People who sign up for a library card: Name and contact info Checkouts of books by who and when etc… Why would a library want to track this information in a database? Data management Centralized location for all data being tracked Computerized and reduces manual processes Use SQL to get insight With SQL the library can answer questions like: Which books are being checked out? What types of books are being checked out? Which books are overdue? For more detailed information on how the SQLite database was put together, refer to the GitHub repository here. 2.1 Entity Relationship Diagrams An entity relationship diagram ERD is a visual representation of a relational database. ERDs help with understanding what data is available, how the data is stored, and how tables and columns are related. These details are important for determining what types of questions you can answer with SQL! Here’s an ERD for the Library Checkouts database: Lets break down the components of the ERD: Entities represent the tables in the database. Attributes represent the columns in the database. Data Types: Each attribute is made up of a certain data type. The most common data types you’ll interact with are numeric, string, date, or boolean. Primary Key (PK): This is a column(s) that uniquely identifies a row in a table. Foreign Key (FK): This is a column that references a primary key. It’s used to identify a relationship between tables. Relationships between tables are represented with lines connecting one entity to another The symbols at the end of the lines represent cardinality, the number of rows between two database tables. NOTE: The Library Checkouts ERD was made with the diagramming software Lucidchart. Lucidchart also does an excellent job of breaking down Entity Relationship Diagrams here. 2.2 Data Definitions Below are the data definitions of the tables and columns in the Library Checkouts Database. users: All users that signed up for a library card with the library column description data type id unique id of the user integer first_name first name of the user text last_name last name of the user text birth_date birth date of the user date phone cell phone of the user text email email address of the user text address address where the the user lives text city city where the user lives text state state where the user lives text zip_code zip code where the user lives integer checkouts: A log of when a user checks out a book from the library column description data type id unique id of the book checkout integer user_id id of the user who checked out a book integer book_id id of the book that was checked out integer checkout_date date the book was checked out by the user date days_checking_out number of days the user will check out the book for integer due_date date the book is due based off days_checking_out date return_date date the book was returned by the user date days_checked_out number of days the book was checked out for integer returned_with_damage a number to distinguish whether the book was returned with damage0 = the book was not returned with damage1 = the book was returned with damage integer books: All the books in the library system column description data type id unique id of the book integer title title of the book text author name of the author text isbn isbn of the book text date_published date the book was published date publisher publisher of the book text format the format of the book Ex) Hardcover text pages the number of pages the book has integer book_genre_link: A table to link books with their respective genre(s) column description data type book_id id of the book integer genre_id id of the genre integer genres: All the genres in the library system column description data type id unique id of the genre integer name name of the genre text 2.3 SQLiteStudio To work with our database, we’ll use SQLiteStudio. It’s a free, open source, multi-platform desktop application for browsing SQLite databases and writing SQL queries. SQLiteStudio has a number of tools and panes to help you interact with your data: You can view databases in the pane outlined in green. You can also write and run queries in the editor pane outlined in orange. 2.3.1 Load the Database Click the “Add a database” icon [3] and the Database Dialog Window will pop up. Database Dialog Window Click the “Browse for existing database file on your local computer” icon Your computer file explorer window will pop up Navigate to the lcdb.db file on your computer and double-click The Database Dialog Window will appear again Click the “OK” button at the bottom right The lcdb.db file will load to the left under the Databases Pane of the interface (outlined in green) Click lcdb under the Databases Pane to highlight Click the “Connect to the database” icon [4] You are now connected to the database and can execute SQL to the database! 2.3.2 Load the SQL Script Click the “Open SQL editor” icon [1] The SQL Editor Pane of the interface will appear (outlined in green) Click the “Load SQL from file” icon [2] Your computer file explorer window will pop up Navigate to the intro_to_sql_spring22.sql file on your computer and double-click The SQL file will load in the SQL Editor Pane. This is where we’ll write our SQL queries! Click the “Save SQL to file” icon to save the queries you write to intro_to_sql_spring22.sql "],["hands-on-with-sql-code.html", "3 Hands-On with SQL Code 3.1 Viewing Data 3.2 Filtering Data 3.3 Aggregating Data 3.4 Joining Data 3.5 Subqueries 3.6 Saving Query Results 3.7 Data Management", " 3 Hands-On with SQL Code 3.1 Viewing Data 3.1.1 SELECT &amp; FROM We’re ready to write our first query! Type this into the SQL Editor Pane: SELECT * FROM users; Place your cursor anywhere on SELECT and then click the Execute query button. This is the most common query you’ll write as you start exploring your data. SELECT is used to display the columns of tables you want and FROM is used to specifiy which table to get the columns from. The query asks the database to select everything (* means “everything”) from the table users. It ends with a semicolon to tell the database that this is the end of the request. SQL ignores capitalization, spaces, and new lines in a query. Some tools which use SQL also ignore semicolons. However, it’s conventional to: Write SQL keywords (SELECT, FROM, and so on) in UPPERCASE Write table and column names in lowercase Write a semicolon ; at the end of the query You can use new lines to help organize queries and make them easier to read. For instance, this query does the same thing as the query above: SELECT * FROM users; 3.1.2 Selecting Columns What if we don’t want to see all of the columns in the table? We can ask for just the columns we want to see. Let’s get the first name, birth date, phone, city, and zip code. SELECT first_name, birth_date, phone, city, zip_code FROM users; NOTE: You can rearrange the columns however you’d like in the SELECT statement and select a column multiple times. 3.1.3 Unique Values In your data exploration, you might want to know which unique values exist in a column. SELECT DISTINCT is the statement we run on one or more columns to achieve this. Let’s look at the users table again and see which cities our users live in. SELECT DISTINCT city FROM users; If we wanted to see unique combinations across multiple columns, we just add the columns we’re interested in. The query below shows unique city and zip code combinations. SELECT DISTINCT city, zip_code FROM users; 3.1.4 Ordering Results While we continue our data exploration, we also might want to sort the results in a specific way. You can sort on one or more columns with a combination of ascending or descending order using the ORDER BY command. Let’s sort the users table by birth date. SELECT * FROM users ORDER BY birth_date; By default, ORDER BY sorts in ascending order. We can sort in descending order to get users born more recently by adding DESC after the column. SELECT * FROM users ORDER BY birth_date DESC; CHALLENGE: How would you sort users by zip code in descending order and then birth date in ascending order? 3.1.5 Limiting Number of Rows Sometimes you’ll be working with a large table to analyze with lots of columns and rows. You can use LIMIT to reduce the number of rows the query returns to give you a snapshot of the data you’re working with. SELECT * FROM users LIMIT 10; 3.1.6 Commenting As we’re writing queries, sometimes we want to write helpful comments to ourselves and others. There’s two ways to write comments so that text won’t be interpreted as SQL. Single line comments: text following two dashses “–”, like so -- comment here Multiline comments: text between the characters “/* */”, like so /* comment here */ /* all users in the library system sorted by most recent birth date */ SELECT * FROM users ORDER BY birth_date DESC; -- sort most recent here CHECKPOINT: Try and use all viewing commands together to give you insight to the dataset. Write your insights in comments. 3.2 Filtering Data Now that we’ve seen some ways to view our data, let’s learn how we can filter our data. This is really the core of SQL, where we can start to answer our own questions about the data! We use the WHERE command to filter rows of a query by specifying one or more conditions. The table below shows comparison operators that can be used and combined with WHERE to create conditions, some of which you may have seen before in other programming languages. Comparison Operator Description = equals &gt; greater than &gt;= greater than or equal to &lt; less than &lt;= less than or equal to &lt;&gt; or != not equal to In general, the type of data on each side of the operator needs to be the same: compare numbers to numbers, text to text, and so on. When working with text or date data, it’s necessary to wrap values in single quotes. For instance: 'text_value' is a text value '2000-01-01' is a date Now let’s write a query to find all users that live in Davis: SELECT * FROM users WHERE city = &#39;Davis&#39;; SQL also provides a variety of arithmetic operators for working with numeric data: Arithmetic Operators Description + addition - subtraction * multiplication / division % modulus 3.2.1 AND &amp; OR Operators Often we’ll need to filter data based on more than one condition. We can ask WHERE to check multiple conditions with the keywords: AND, meaning a record must satisfy both conditions OR, meaning a record must satisfy at least one of two conditions These are logical operators in SQL that evaluate to TRUE or FALSE. Let’s find all users who live in Davis and have a zip code of 95616. SELECT * FROM users WHERE city = &#39;Davis&#39; AND zip_code = 95616; Let’s now find all users who live in Davis or Sacramento. SELECT * FROM users WHERE city = &#39;Davis&#39; OR city = &#39;Sacramento&#39;; NOTE: AND &amp; OR will follow the order of operations. To use AND &amp; OR in the same query, wrap parenthesis around the OR conditions. 3.2.2 IN Operator Sometimes we find ourselves writing multiple OR conditions on the same column which can make our query look more complex than it really is. In this scenario we can condense multiple OR conditions using IN. Let’s rewrite our previous query to use IN. SELECT * FROM users WHERE city IN (&#39;Davis&#39;, &#39;Sacramento&#39;); 3.2.3 BETWEEN Operator We can also also filter using ranges of values with BETWEEN. This is handy when you’re working with numerical or date values and you don’t want to list out all possible values to meet your conditions. Let’s write a query to find all users born in the 1990’s. SELECT * FROM users WHERE birth_date BETWEEN &#39;1990-01-01&#39; AND &#39;1999-12-31&#39;; CHALLENGE: Find all users with a zip code from 95000 - 96000. 3.2.4 LIKE Operator LIKE is used to search for patterns in strings using the wildcard %, which matches any one character. LIKE is case-insensitive. Let’s look at an example to indicate we want to match the beginning of a string, but the end is allowed to vary. To show this, let’s find users that have a phone number area code that begins with 530 and can end with anything. SELECT * FROM users WHERE phone LIKE &#39;530%&#39;; NOTE: The wildcard % can be used multiple times in one pattern. You can also use regular expressions in SQLite to match in more complicated situations. Read more about using regular expressions here. CHALLENGE: How would you write a query so that the wild card finds users with an email that ends with icloud.com? 3.2.5 IS NULL Operator So far we’ve worked with complete data, but how do we work with missing data? In databases, NULL means missing data. IS NULL is used to test whether there is missing data in a column. Let’s look at an example to find users with a missing address. SELECT * FROM users WHERE address IS NULL; CHALLENGE: How would you write a query to find users with a missing phone number or missing email? 3.2.6 NOT Operator There will be times where we want to find only the rows that do not satisfy some condition. To do this, use NOT combined with other operators: NOT IN NOT BETWEEN NOT LIKE IS NOT NULL Below is a query to find users that do not have a phone number area code that begins with 530. SELECT * FROM users WHERE phone NOT LIKE &#39;530%&#39;; 3.3 Aggregating Data We’ve just looked at a number of ways to filter data, but now let’s look at some ways to aggregate data. 3.3.1 Count Suppose we want to find out how many books have been checked out. We can count the total number of rows in a table using the COUNT function. The function takes a column or * as an argument, but the argument doesn’t actually affect the count. Here’s how we can use COUNT to answer our question: SELECT COUNT(id) FROM checkouts; NOTE: You can combine DISTINCT with COUNT using COUNT(DISTINCT column_name) to get a unique count of values in a column when duplicate values exist. CHALLENGE: Find the total number of users that have checked out a book. 3.3.1.1 Renaming/Aliasing Columns In the previous query, notice that the name of the column in the result is COUNT(id), which isn’t easy to use in subsequent SQL queries or with other data programming tools. We can use AS to rename or alias a column in the result of the query. This is handy if you’re planning to export the result for future use, especially if you’re sending it to someone else. Let’s rename the column to total_checkouts: SELECT COUNT(id) AS total_checkouts FROM checkouts; We can also include WHERE. Let’s see how many books were checked out just today. SELECT COUNT(id) AS total_checkouts FROM checkouts WHERE checkout_date = &#39;2022-04-11&#39;; 3.3.2 Average The AVG function returns the average value of a numeric column. Let’s find the average number of days a book is checked out for: SELECT AVG(days_checking_out) AS avg_days_checking_out FROM checkouts; 3.3.3 Sum We can also sum the values in a numeric column with the SUM function. Let’s find the total number of books that were returned with damage: SELECT SUM(returned_with_damage) AS books_returned_with_damage FROM checkouts; Here’s another way to accomplish the same task using COUNT and WHERE: SELECT COUNT(id) AS books_returned_with_damage FROM checkouts WHERE returned_with_damage = 1; 3.3.4 Grouping Data So now you’ve seen several functions working on a single column, but we sometimes want to summarize our data in more sophisticated ways. Let’s see what grouping can do for our data. Let’s write a query that counts the number of books checked out per day: SELECT checkout_date, COUNT(book_id) AS books_checked_out FROM checkouts GROUP BY checkout_date; Notice here how we asked for two columns - the checkout_date and the count of book_id. CHALLENGE: You can also GROUP BY more than one column. How would you find the total number of times a person checked out a book on a given day? 3.3.5 Having HAVING is similar to WHERE, but it specifically works with GROUP BY. Perhaps we’re only interested in days that had more than 5 checkouts. Let’s see what that looks like: SELECT checkout_date, COUNT(book_id) AS books_checked_out FROM checkouts GROUP BY checkout_date HAVING COUNT(book_id) &gt; 5; Now we’ve seen how we can use functions to aggregate data and how grouping data can give us meaningful insights. There are, of course, other functions available in SQL and we can’t go over all of them here, but now you’ve seen how they work and can apply your knowledge to new functions you find. 3.4 Joining Data Joining tables allows us to combine information from more than one table into a new table. The tables need to have a key to do so. In our Library Checkouts ERD, the id column in books is a key column that links to book_id in checkouts and book_id in book_genre_link 3.4.1 JOIN Types SQL has 4 main kinds of joins: NOTE: The above images come from the W3Schools’ SQL join page, an excellent resource for learning more about SQL. What kinds of joins are there? INNER JOIN: Returns records that have matching values in both tables; it gets you what’s in the middle of the venn diagram. LEFT JOIN: Returns all records from the left table, and the matched records from the right table; the “left” table is the first table you write in the query. RIGHT JOIN: Returns all records from the right table, and the matched records from the left table; the “right” table is the second table you write in the query or the “join” table. NOTE: This is not supported in SQLite, however switching the tables in a LEFT JOIN will emulate a RIGHT JOIN. FULL OUTER JOIN: Returns all records when there is a match in either left or right table; nulls are generated in the table when a row in one table doesn’t have a match in the other table. NOTE: This is not supported in SQLite, however you can emulate a FULL OUTER JOIN described here. 3.4.2 JOIN steps Below are the steps for writing a JOIN: SELECT the columns we want in the output (using column references). NOTE: Column referencing helps you distinguish from what table the columns come from. Use the table name followed by a period to reference the column: table_name.column_name. Then we have the FROM statement to tell it which table to start with (this is our “left” table). Then we need our JOIN statement to say which table should get joined (this is our “right” table) Finally, we have to say which columns the join should be based on with ON . 3.4.3 INNER JOIN Let’s try an INNER JOIN to see how this works: SELECT checkouts.user_id, books.title AS book, checkouts.checkout_date FROM books INNER JOIN checkouts ON books.id = checkouts.book_id; We interpret the INNER JOIN query as, “all books that have been checked out.” NOTE: Notice that you can alias a table and columns in the same query. This will come handy when we learn about JOIN! CHALLENEGE: How would you reference the columns when the table is aliased? Can you use users, students, or both? 3.4.4 LEFT JOIN Now let’s try a LEFT JOIN: SELECT checkouts.user_id, books.title AS book, checkouts.checkout_date FROM books LEFT JOIN checkouts ON books.id = checkouts.book_id; We interpret the LEFT JOIN query as, “all books and if they have been checked out or not.” You might be thinking, what would happed if the tables in the LEFT JOIN were flipped? We would get the same result as the INNER JOIN query! That’s because there’s no instances where a checkout without a book could ever happen! CHALLENGE: Can you write a query that contains the title of the books and the names of the genres they’re categorized to? 3.5 Subqueries So far we’ve been working with one SELECT statement, but we can actually combine multiple SELECT statements using subqueries. Subqueries are nested queries enclosed in parentheses that can be used with other commands like JOIN and WHERE. Below are 2 examples of these use cases. Let’s first look at a subquery in the WHERE clause: -- main query SELECT * FROM checkouts WHERE book_id IN ( -- subquery SELECT id FROM books WHERE format = &#39;Hardcover&#39; ); We retrieve hardcover books in a subquery. We then use the results of the subquery to filter the checkouts table using checkouts.book_id. In the end we get, “all checked out hardcover books.” NOTE: When writing a subquery with WHERE and IN, the subquery must select only one column for IN to filter on. Now let’s look at a subquery with JOIN: -- main query SELECT checkouts.user_id, hardcover_books.title AS book, checkouts.checkout_date, checkouts.return_date FROM checkouts INNER JOIN ( -- subquery SELECT * FROM books WHERE format = &#39;Hardcover&#39; ) AS hardcover_books ON checkouts.book_id = hardcover_books.id; We retrieve hardcover books in a subquery, just like before. Next, we write the subquery after JOIN and alias it hardcover_books. Finally, we join on the keys and return the columns we want in the main SELECT statement. NOTE: If you’re still a bit confused, just remember that every query results in a table. Subqueries give you the ability to create a “new” table on the fly even if that table didn’t exist in the database before. Also, note that both subquery examples are just different ways to get to the same result, “checked out hardcover books.” 3.6 Saving Query Results There will be times when we want to save the results of a query so we can reuse it later when needed. Two commands to save a query as a new database object follow: CREATE TEMPORARY TABLE This is a new table added to the database, just like the tables you’ve been working with, except it is only available in the current session. You typically do this to break down a complex problem into intermediate steps and pass your saved results to the final query. CREATE VIEW A view is simply a saved query that can be executed when called. The query you save will usually be made up of multiple tables with added conditions if needed. You can use it in pretty much the same way you would a table. The only major difference is that a view, because it is updating from other tables, is not able to be edited. If we want to create a temporary table, we just need to add CREATE TEMPORARY TABLE our_new_table_name AS at the beginning of the query (adding in our own table name, of course). This is what it looks like: CREATE TEMPORARY TABLE davis_resident_checkouts AS SELECT users.id AS user_id, users.first_name, users.last_name, books.title AS book, checkouts.checkout_date, checkouts.return_date FROM users INNER JOIN checkouts ON users.id = checkouts.user_id INNER JOIN books ON checkouts.book_id = books.id WHERE users.city = &#39;Davis&#39;; In much the same way we made the new table, we can make a view: CREATE VIEW davis_resident_checkouts AS SELECT users.id AS user_id, users.first_name, users.last_name, books.title AS book, checkouts.checkout_date, checkouts.return_date FROM users INNER JOIN checkouts ON users.id = checkouts.user_id INNER JOIN books ON checkouts.book_id = books.id WHERE users.city = &#39;Davis&#39;; 3.7 Data Management 3.7.1 Update Tables You might have noticed at the beginning the users table has NULL values across different columns. We can fix this fairly easily, but we need to be careful. It’s challenging to undo something in a database so we want to be sure we’re doing it right. Let’s update the NULL values in the users.address to “N/A”. It’s first helpful to write a query to be sure these are the records you want to update: SELECT * FROM users WHERE address IS NULL; Once you’ve confirmed, the below statement updates the NULL values to “N/A” UPDATE users SET address = &#39;N/A&#39; WHERE address IS NULL; The SET command specifically targets just the address column and replaces NULL values with “N/A” when the condition is met in the WHERE clause. It leaves the other values alone. If the WHERE clause is removed, it will set all values in the whole column to “N/A” overwriting the users address, so proceed with caution! 3.7.2 Add &amp; Populate a Column Sometimes we want to make a new column and add data into it. Let’s make a new column called country in the users table and populate it with “USA” if there is a value in the column state. First we’ll add the column and set the default value to “N/A”: ALTER TABLE users ADD country TEXT DEFAULT &#39;N/A&#39;; NOTE: The DEFAULT argument is optional, but if you leave it blank, it will make the default value NULL. Now we update all values in the column to be “USA” where the state is not null. UPDATE users SET country = &#39;USA&#39; WHERE state IS NOT NULL; "],["conclusion.html", "Conclusion", " Conclusion We covered a wide variety of SQL processes you might need in setting up a database and querying data. Did we cover everything you might need to know? Of course not. It’s only a 3 hour workshop and SQL is a big language. I highly encourage you to look at the resources below to learn more and expand your SQL skills. I also welcome pull requests and submitting issues for typo fixes or ideas for additional content. Resources W3Schools SQL Materials - This is an excellent reference for SQL syntax with a fun “try it yourself” feature. Sofware Carpentry’s SQL Novice Workshop Clark Fitzgeralds &amp; Nick Ulle’s SQL Workshop Clark Fitzgeralds &amp; Nick Ulle’s SQL Cheatsheet Michele Tobias’ Spatial SQL Workshop Lucidchart’s Entity Relationship Diagrams Overview Diversify Data Science’s Library Checkout Database - v0.1.0-alpha Working with SQL databases and queries in R: University of Michigan’s Stat 701 Class Notes RStudio’s Database Queries with R "]]
